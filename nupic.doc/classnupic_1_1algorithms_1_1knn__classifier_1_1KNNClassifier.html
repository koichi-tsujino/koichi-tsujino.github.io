<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: nupic.algorithms.knn_classifier.KNNClassifier Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nupic</b></li><li class="navelem"><b>algorithms</b></li><li class="navelem"><b>knn_classifier</b></li><li class="navelem"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html">KNNClassifier</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nupic.algorithms.knn_classifier.KNNClassifier Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for nupic.algorithms.knn_classifier.KNNClassifier:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.png" usemap="#nupic.algorithms.knn_5Fclassifier.KNNClassifier_map" alt=""/>
  <map id="nupic.algorithms.knn_5Fclassifier.KNNClassifier_map" name="nupic.algorithms.knn_5Fclassifier.KNNClassifier_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a03d38e37cee419f65195423c9c1f9a35"><td class="memItemLeft" align="right" valign="top"><a id="a03d38e37cee419f65195423c9c1f9a35"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self, k=1, exact=False, distanceNorm=2.0, distanceMethod=&quot;norm&quot;, distThreshold=0, doBinarization=False, binarizationThreshold=0.5, useSparseMemory=True, sparseThreshold=0.1, relativeThreshold=False, numWinners=0, numSVDSamples=None, numSVDDims=None, fractionOfMax=None, verbosity=0, maxStoredPatterns=-1, replaceDuplicates=False, cellsPerCol=0, minSparsity=0.0)</td></tr>
<tr class="separator:a03d38e37cee419f65195423c9c1f9a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6053743a99a6d393cfae63d832b7b3e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a6053743a99a6d393cfae63d832b7b3e4">clear</a> (self)</td></tr>
<tr class="separator:a6053743a99a6d393cfae63d832b7b3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ac8e70daead1468a7db6f7fcd28dd0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#ab1ac8e70daead1468a7db6f7fcd28dd0">prototypeSetCategory</a> (self, idToCategorize, newCategory)</td></tr>
<tr class="separator:ab1ac8e70daead1468a7db6f7fcd28dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d715f8ccd363c714b85816b48ffc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a504d715f8ccd363c714b85816b48ffc4">removeIds</a> (self, idsToRemove)</td></tr>
<tr class="separator:a504d715f8ccd363c714b85816b48ffc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89e5ed44def8d3dc03d7b2033ae8539"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#aa89e5ed44def8d3dc03d7b2033ae8539">removeCategory</a> (self, categoryToRemove)</td></tr>
<tr class="separator:aa89e5ed44def8d3dc03d7b2033ae8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc03d759531ae49ee162f8a8887e7b92"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#abc03d759531ae49ee162f8a8887e7b92">doIteration</a> (self)</td></tr>
<tr class="separator:abc03d759531ae49ee162f8a8887e7b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15282d807ba6c5787870da3c6b19e163"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a15282d807ba6c5787870da3c6b19e163">learn</a> (self, inputPattern, inputCategory, partitionId=None, isSparse=0, rowID=None)</td></tr>
<tr class="separator:a15282d807ba6c5787870da3c6b19e163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af820fbe7cbba38694a705a1d503523bd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#af820fbe7cbba38694a705a1d503523bd">getOverlaps</a> (self, inputPattern)</td></tr>
<tr class="separator:af820fbe7cbba38694a705a1d503523bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4609c0ab3f7ea7209ba187cfd474da"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#acf4609c0ab3f7ea7209ba187cfd474da">getDistances</a> (self, inputPattern)</td></tr>
<tr class="separator:acf4609c0ab3f7ea7209ba187cfd474da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bfb66151547cad4325ea7b8e66c97e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a90bfb66151547cad4325ea7b8e66c97e">infer</a> (self, inputPattern, computeScores=True, overCategories=True, partitionId=None)</td></tr>
<tr class="separator:a90bfb66151547cad4325ea7b8e66c97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6326b1f5c5f9ca841ae4299b49368312"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a6326b1f5c5f9ca841ae4299b49368312">getClosest</a> (self, inputPattern, topKCategories=3)</td></tr>
<tr class="separator:a6326b1f5c5f9ca841ae4299b49368312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8c0c7a54f152cb47b6f7eafb8a6fdc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#aca8c0c7a54f152cb47b6f7eafb8a6fdc">closestTrainingPattern</a> (self, inputPattern, cat)</td></tr>
<tr class="separator:aca8c0c7a54f152cb47b6f7eafb8a6fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4bd90b1f6c4625ee986d5d0cbf51f5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a4a4bd90b1f6c4625ee986d5d0cbf51f5">closestOtherTrainingPattern</a> (self, inputPattern, cat)</td></tr>
<tr class="separator:a4a4bd90b1f6c4625ee986d5d0cbf51f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f39b736462277f168c03ae49669327"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#ac5f39b736462277f168c03ae49669327">getPattern</a> (self, idx, sparseBinaryForm=False, cat=None)</td></tr>
<tr class="separator:ac5f39b736462277f168c03ae49669327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543854610f5d4bea9800a0245c3df805"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a543854610f5d4bea9800a0245c3df805">getPartitionId</a> (self, i)</td></tr>
<tr class="separator:a543854610f5d4bea9800a0245c3df805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06b54bfc41bb07666b0494df4ce274c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#ab06b54bfc41bb07666b0494df4ce274c">getPartitionIdList</a> (self)</td></tr>
<tr class="separator:ab06b54bfc41bb07666b0494df4ce274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aba18c2a46a8f6d3437c3d9868a73a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a25aba18c2a46a8f6d3437c3d9868a73a">getNumPartitionIds</a> (self)</td></tr>
<tr class="separator:a25aba18c2a46a8f6d3437c3d9868a73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2ea381ef8e7a65df9acc2ff6d6395a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a2f2ea381ef8e7a65df9acc2ff6d6395a">getPartitionIdKeys</a> (self)</td></tr>
<tr class="separator:a2f2ea381ef8e7a65df9acc2ff6d6395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772f3cdb1de4175fc27f0e2f0de2b9d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#ab772f3cdb1de4175fc27f0e2f0de2b9d">getPatternIndicesWithPartitionId</a> (self, partitionId)</td></tr>
<tr class="separator:ab772f3cdb1de4175fc27f0e2f0de2b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab255f20c9590619aca4c67d03b1f8e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#aaab255f20c9590619aca4c67d03b1f8e">finishLearning</a> (self)</td></tr>
<tr class="separator:aaab255f20c9590619aca4c67d03b1f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f43d7e6ccaade7cffc1954fa46d50e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a0f43d7e6ccaade7cffc1954fa46d50e2">computeSVD</a> (self, numSVDSamples=None, finalize=True)</td></tr>
<tr class="separator:a0f43d7e6ccaade7cffc1954fa46d50e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2939835ce4315c858d3d7839be244"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#aaea2939835ce4315c858d3d7839be244">getAdaptiveSVDDims</a> (self, singularValues, fractionOfMax=0.001)</td></tr>
<tr class="separator:aaea2939835ce4315c858d3d7839be244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa494c742454e9b95c8e27cb0b3160db3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#aa494c742454e9b95c8e27cb0b3160db3">remapCategories</a> (self, mapping)</td></tr>
<tr class="separator:aa494c742454e9b95c8e27cb0b3160db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac147604f38e382b530288587555d0c7c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#ac147604f38e382b530288587555d0c7c">setCategoryOfVectors</a> (self, vectorIndices, categoryIndices)</td></tr>
<tr class="separator:ac147604f38e382b530288587555d0c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc8bdb5b45a346f02cd6735e5149899"><td class="memItemLeft" align="right" valign="top"><a id="a2fc8bdb5b45a346f02cd6735e5149899"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (cls, proto)</td></tr>
<tr class="separator:a2fc8bdb5b45a346f02cd6735e5149899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32f13fd0b249fa10ac6b909f170ec97"><td class="memItemLeft" align="right" valign="top"><a id="ad32f13fd0b249fa10ac6b909f170ec97"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (self, proto)</td></tr>
<tr class="separator:ad32f13fd0b249fa10ac6b909f170ec97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e37649a8bc4fa62cd10dfe5085bf4ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#a1e37649a8bc4fa62cd10dfe5085bf4ee">__getstate__</a> (self)</td></tr>
<tr class="separator:a1e37649a8bc4fa62cd10dfe5085bf4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50255fc94e6c96d73f53f54434f07ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1knn__classifier_1_1KNNClassifier.html#aa50255fc94e6c96d73f53f54434f07ff">__setstate__</a> (self, state)</td></tr>
<tr class="separator:aa50255fc94e6c96d73f53f54434f07ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23c4e32eb1a91d65e47d1a77b766d3cc"><td class="memItemLeft" align="right" valign="top"><a id="a23c4e32eb1a91d65e47d1a77b766d3cc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>getSchema</b> ()</td></tr>
<tr class="separator:a23c4e32eb1a91d65e47d1a77b766d3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5f760b33256d71640fe30369ea8ecac0"><td class="memItemLeft" align="right" valign="top"><a id="a5f760b33256d71640fe30369ea8ecac0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>version</b></td></tr>
<tr class="separator:a5f760b33256d71640fe30369ea8ecac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f91dffc43ed7da0f2bb68695fcc032a"><td class="memItemLeft" align="right" valign="top"><a id="a7f91dffc43ed7da0f2bb68695fcc032a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>k</b></td></tr>
<tr class="separator:a7f91dffc43ed7da0f2bb68695fcc032a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d8907a4590d669143d2b5f216f7904"><td class="memItemLeft" align="right" valign="top"><a id="af6d8907a4590d669143d2b5f216f7904"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>exact</b></td></tr>
<tr class="separator:af6d8907a4590d669143d2b5f216f7904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0835f30f162c61272bcfb53a210a830c"><td class="memItemLeft" align="right" valign="top"><a id="a0835f30f162c61272bcfb53a210a830c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>distanceNorm</b></td></tr>
<tr class="separator:a0835f30f162c61272bcfb53a210a830c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf064aaf79165959a491e7daae5ce0"><td class="memItemLeft" align="right" valign="top"><a id="aacaf064aaf79165959a491e7daae5ce0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>distanceMethod</b></td></tr>
<tr class="separator:aacaf064aaf79165959a491e7daae5ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f6d110b77ca95734bcc79ad9b5e29b"><td class="memItemLeft" align="right" valign="top"><a id="ac8f6d110b77ca95734bcc79ad9b5e29b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>distThreshold</b></td></tr>
<tr class="separator:ac8f6d110b77ca95734bcc79ad9b5e29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8541a768efdcd13aa68bdf4181bd1d65"><td class="memItemLeft" align="right" valign="top"><a id="a8541a768efdcd13aa68bdf4181bd1d65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>doBinarization</b></td></tr>
<tr class="separator:a8541a768efdcd13aa68bdf4181bd1d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a059c93d702c82e44a4db061d58b1a"><td class="memItemLeft" align="right" valign="top"><a id="ab1a059c93d702c82e44a4db061d58b1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>binarizationThreshold</b></td></tr>
<tr class="separator:ab1a059c93d702c82e44a4db061d58b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b5934e86e50eb859b98f6707273b35"><td class="memItemLeft" align="right" valign="top"><a id="a35b5934e86e50eb859b98f6707273b35"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>useSparseMemory</b></td></tr>
<tr class="separator:a35b5934e86e50eb859b98f6707273b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb3feea83bd983c9ddd996cb76028e8"><td class="memItemLeft" align="right" valign="top"><a id="a5bb3feea83bd983c9ddd996cb76028e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sparseThreshold</b></td></tr>
<tr class="separator:a5bb3feea83bd983c9ddd996cb76028e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737f7632a436e889ac0996d6d76174ba"><td class="memItemLeft" align="right" valign="top"><a id="a737f7632a436e889ac0996d6d76174ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>relativeThreshold</b></td></tr>
<tr class="separator:a737f7632a436e889ac0996d6d76174ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7daed12ca2178f6e4a95f7bd79136f"><td class="memItemLeft" align="right" valign="top"><a id="a9f7daed12ca2178f6e4a95f7bd79136f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>numWinners</b></td></tr>
<tr class="separator:a9f7daed12ca2178f6e4a95f7bd79136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b30c0e13187864924b80fc328c109d3"><td class="memItemLeft" align="right" valign="top"><a id="a8b30c0e13187864924b80fc328c109d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>numSVDSamples</b></td></tr>
<tr class="separator:a8b30c0e13187864924b80fc328c109d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc108f73b1f0d8c204afcfcc4c953718"><td class="memItemLeft" align="right" valign="top"><a id="acc108f73b1f0d8c204afcfcc4c953718"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>numSVDDims</b></td></tr>
<tr class="separator:acc108f73b1f0d8c204afcfcc4c953718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd57cd85b8fa8146e6f7ff8f74e1614"><td class="memItemLeft" align="right" valign="top"><a id="a6cd57cd85b8fa8146e6f7ff8f74e1614"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fractionOfMax</b></td></tr>
<tr class="separator:a6cd57cd85b8fa8146e6f7ff8f74e1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9c80374810dc78ccf1ff48be7f176e"><td class="memItemLeft" align="right" valign="top"><a id="a3d9c80374810dc78ccf1ff48be7f176e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>verbosity</b></td></tr>
<tr class="separator:a3d9c80374810dc78ccf1ff48be7f176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fdf88280215d220f609e4a5d40acca"><td class="memItemLeft" align="right" valign="top"><a id="ae6fdf88280215d220f609e4a5d40acca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>replaceDuplicates</b></td></tr>
<tr class="separator:ae6fdf88280215d220f609e4a5d40acca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065441809909659e03539d6940016f98"><td class="memItemLeft" align="right" valign="top"><a id="a065441809909659e03539d6940016f98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cellsPerCol</b></td></tr>
<tr class="separator:a065441809909659e03539d6940016f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414ef008604863db6710d1babc3fdc3d"><td class="memItemLeft" align="right" valign="top"><a id="a414ef008604863db6710d1babc3fdc3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>maxStoredPatterns</b></td></tr>
<tr class="separator:a414ef008604863db6710d1babc3fdc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670d54539789add587d29279235ae4ee"><td class="memItemLeft" align="right" valign="top"><a id="a670d54539789add587d29279235ae4ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>minSparsity</b></td></tr>
<tr class="separator:a670d54539789add587d29279235ae4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646c000df2e81716e3336c0d2ae71e2e"><td class="memItemLeft" align="right" valign="top"><a id="a646c000df2e81716e3336c0d2ae71e2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fixedCapacity</b></td></tr>
<tr class="separator:a646c000df2e81716e3336c0d2ae71e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This class implements NuPIC's k Nearest Neighbor Classifier. KNN is very
useful as a basic classifier for many situations. This implementation contains
many enhancements that are useful for HTM experiments. These enhancements
include an optimized C++ class for sparse vectors, support for continuous
online learning, support for various distance methods (including Lp-norm and
raw overlap), support for performing SVD on the input vectors (very useful for
large vectors), support for a fixed-size KNN, and a mechanism to store custom
ID's for each vector.

:param k: (int) The number of nearest neighbors used in the classification
    of patterns. Must be odd.

:param exact: (boolean) If true, patterns must match exactly when assigning
    class labels

:param distanceNorm: (int) When distance method is "norm", this specifies
    the p value of the Lp-norm

:param distanceMethod: (string) The method used to compute distance between
    input patterns and prototype patterns. The possible options are:

    - ``norm``: When distanceNorm is 2, this is the euclidean distance,
            When distanceNorm is 1, this is the manhattan distance
            In general: sum(abs(x-proto) ^ distanceNorm) ^ (1/distanceNorm)
            The distances are normalized such that farthest prototype from
            a given input is 1.0.
    - ``rawOverlap``: Only appropriate when inputs are binary. This computes:
            (width of the input) - (# bits of overlap between input
            and prototype).
    - ``pctOverlapOfInput``: Only appropriate for binary inputs. This computes
            1.0 - (# bits overlap between input and prototype) /
                    (# ON bits in input)
    - ``pctOverlapOfProto``: Only appropriate for binary inputs. This computes
            1.0 - (# bits overlap between input and prototype) /
                    (# ON bits in prototype)
    - ``pctOverlapOfLarger``: Only appropriate for binary inputs. This computes
            1.0 - (# bits overlap between input and prototype) /
                    max(# ON bits in input, # ON bits in prototype)

:param distThreshold: (float) A threshold on the distance between learned
    patterns and a new pattern proposed to be learned. The distance must be
    greater than this threshold in order for the new pattern to be added to
    the classifier's memory.

:param doBinarization: (boolean) If True, then scalar inputs will be
    binarized.

:param binarizationThreshold: (float) If doBinarization is True, this
    specifies the threshold for the binarization of inputs

:param useSparseMemory: (boolean) If True, classifier will use a sparse
    memory matrix

:param sparseThreshold: (float) If useSparseMemory is True, input variables
    whose absolute values are less than this threshold will be stored as
    zero

:param relativeThreshold: (boolean) Flag specifying whether to multiply
    sparseThreshold by max value in input

:param numWinners: (int) Number of elements of the input that are stored. If
    0, all elements are stored

:param numSVDSamples: (int) Number of samples the must occur before a SVD
    (Singular Value Decomposition) transformation will be performed. If 0,
    the transformation will never be performed

:param numSVDDims: (string) Controls dimensions kept after SVD
    transformation. If "adaptive", the number is chosen automatically

:param fractionOfMax: (float) If numSVDDims is "adaptive", this controls the
    smallest singular value that is retained as a fraction of the largest
    singular value

:param verbosity: (int) Console verbosity level where 0 is no output and
    larger integers provide increasing levels of verbosity

:param maxStoredPatterns: (int) Limits the maximum number of the training
    patterns stored. When KNN learns in a fixed capacity mode, the unused
    patterns are deleted once the number of stored patterns is greater than
    maxStoredPatterns. A value of -1 is no limit

:param replaceDuplicates: (bool) A boolean flag that determines whether,
    during learning, the classifier replaces duplicates that match exactly,
    even if distThreshold is 0. Should be True for online learning

:param cellsPerCol: (int) If &gt;= 1, input is assumed to be organized into
    columns, in the same manner as the temporal memory AND whenever a new
    prototype is stored, only the start cell (first cell) is stored in any
    bursting column

:param minSparsity: (float) If useSparseMemory is set, only vectors with
    sparsity &gt;= minSparsity will be stored during learning. A value of 0.0
    implies all vectors will be stored. A value of 0.1 implies only vectors
    with at least 10% sparsity will be stored</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e37649a8bc4fa62cd10dfe5085bf4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e37649a8bc4fa62cd10dfe5085bf4ee">&#9670;&nbsp;</a></span>__getstate__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.__getstate__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return serializable state.

This function will return a version of the __dict__.
</pre> 
</div>
</div>
<a id="aa50255fc94e6c96d73f53f54434f07ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50255fc94e6c96d73f53f54434f07ff">&#9670;&nbsp;</a></span>__setstate__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.__setstate__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set the state of this object from a serialized state.</pre> 
</div>
</div>
<a id="a6053743a99a6d393cfae63d832b7b3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6053743a99a6d393cfae63d832b7b3e4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.clear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clears the state of the KNNClassifier.</pre> 
</div>
</div>
<a id="a4a4bd90b1f6c4625ee986d5d0cbf51f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4bd90b1f6c4625ee986d5d0cbf51f5">&#9670;&nbsp;</a></span>closestOtherTrainingPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.closestOtherTrainingPattern </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the closest training pattern that is *not* of the given
category "cat".

:param inputPattern: The pattern whose closest neighbor is sought

:param cat: Training patterns of this category will be ignored no matter
their distance to inputPattern

:returns: A dense version of the closest training pattern, or None if no
such patterns exist
</pre> 
</div>
</div>
<a id="aca8c0c7a54f152cb47b6f7eafb8a6fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8c0c7a54f152cb47b6f7eafb8a6fdc">&#9670;&nbsp;</a></span>closestTrainingPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.closestTrainingPattern </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the closest training pattern to inputPattern that belongs to
category "cat".

:param inputPattern: The pattern whose closest neighbor is sought

:param cat: The required category of closest neighbor

:returns: A dense version of the closest training pattern, or None if no
such patterns exist
</pre> 
</div>
</div>
<a id="a0f43d7e6ccaade7cffc1954fa46d50e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f43d7e6ccaade7cffc1954fa46d50e2">&#9670;&nbsp;</a></span>computeSVD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.computeSVD </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numSVDSamples</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>finalize</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the singular value decomposition (SVD). The SVD is a factorization
of a real or complex matrix. It factors the matrix `a` as
`u * np.diag(s) * v`, where `u` and `v` are unitary and `s` is a 1-d array
of `a`'s singular values.

**Reason for computing the SVD:**

There are cases where you want to feed a lot of vectors to the
KNNClassifier. However, this can be slow. You can speed up training by (1)
computing the SVD of the input patterns which will give you the
eigenvectors, (2) only keeping a fraction of the eigenvectors, and (3)
projecting the input patterns onto the remaining eigenvectors.

Note that all input patterns are projected onto the eigenvectors in the same
fashion. Keeping only the highest eigenvectors increases training
performance since it reduces the dimensionality of the input.

:param numSVDSamples: (int) the number of samples to use for the SVD
                  computation.

:param finalize: (bool) whether to apply SVD to the input patterns.

:returns: (array) The singular values for every matrix, sorted in
       descending order.
</pre> 
</div>
</div>
<a id="abc03d759531ae49ee162f8a8887e7b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc03d759531ae49ee162f8a8887e7b92">&#9670;&nbsp;</a></span>doIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.doIteration </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Utility method to increment the iteration index. Intended for models that
don't learn each timestep.
</pre> 
</div>
</div>
<a id="aaab255f20c9590619aca4c67d03b1f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab255f20c9590619aca4c67d03b1f8e">&#9670;&nbsp;</a></span>finishLearning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.finishLearning </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Used for batch scenarios.  This method needs to be called between learning
and inference.
</pre> 
</div>
</div>
<a id="aaea2939835ce4315c858d3d7839be244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea2939835ce4315c858d3d7839be244">&#9670;&nbsp;</a></span>getAdaptiveSVDDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getAdaptiveSVDDims </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>singularValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fractionOfMax</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the number of eigenvectors (singularValues) to keep.

:param singularValues:
:param fractionOfMax:
:return:
</pre> 
</div>
</div>
<a id="a6326b1f5c5f9ca841ae4299b49368312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6326b1f5c5f9ca841ae4299b49368312">&#9670;&nbsp;</a></span>getClosest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getClosest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>topKCategories</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the index of the pattern that is closest to inputPattern,
the distances of all patterns to inputPattern, and the indices of the k
closest categories.
</pre> 
</div>
</div>
<a id="acf4609c0ab3f7ea7209ba187cfd474da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4609c0ab3f7ea7209ba187cfd474da">&#9670;&nbsp;</a></span>getDistances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getDistances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputPattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the distances between the input pattern and all other
stored patterns.

:param inputPattern: pattern to check distance with

:returns: (distances, categories) numpy arrays of the same length.
- overlaps: an integer overlap amount for each category
- categories: category index for each element of distances
</pre> 
</div>
</div>
<a id="a25aba18c2a46a8f6d3437c3d9868a73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25aba18c2a46a8f6d3437c3d9868a73a">&#9670;&nbsp;</a></span>getNumPartitionIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getNumPartitionIds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:returns: the number of unique partition Ids stored.
</pre> 
</div>
</div>
<a id="af820fbe7cbba38694a705a1d503523bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af820fbe7cbba38694a705a1d503523bd">&#9670;&nbsp;</a></span>getOverlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getOverlaps </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputPattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the degree of overlap between an input pattern and each category
stored in the classifier. The overlap is computed by computing:

.. code-block:: python

  logical_and(inputPattern != 0, trainingPattern != 0).sum()

:param inputPattern: pattern to check overlap of

:returns: (overlaps, categories) Two numpy arrays of the same length, where:

        * overlaps: an integer overlap amount for each category
        * categories: category index for each element of overlaps
</pre> 
</div>
</div>
<a id="a543854610f5d4bea9800a0245c3df805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543854610f5d4bea9800a0245c3df805">&#9670;&nbsp;</a></span>getPartitionId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getPartitionId </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets the partition id given an index.

:param i: index of partition
:returns: the partition id associated with pattern i. Returns None if no id
is associated with it.
</pre> 
</div>
</div>
<a id="a2f2ea381ef8e7a65df9acc2ff6d6395a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2ea381ef8e7a65df9acc2ff6d6395a">&#9670;&nbsp;</a></span>getPartitionIdKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getPartitionIdKeys </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:returns: a list containing unique (non-None) partition Ids (just the keys)
</pre> 
</div>
</div>
<a id="ab06b54bfc41bb07666b0494df4ce274c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06b54bfc41bb07666b0494df4ce274c">&#9670;&nbsp;</a></span>getPartitionIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getPartitionIdList </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:returns: a list of complete partition id objects
</pre> 
</div>
</div>
<a id="ac5f39b736462277f168c03ae49669327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f39b736462277f168c03ae49669327">&#9670;&nbsp;</a></span>getPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getPattern </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparseBinaryForm</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cat</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets a training pattern either by index or category number.

:param idx: Index of the training pattern

:param sparseBinaryForm: If true, returns a list of the indices of the
non-zero bits in the training pattern

:param cat: If not None, get the first pattern belonging to category cat. If
this is specified, idx must be None.

:returns: The training pattern with specified index
</pre> 
</div>
</div>
<a id="ab772f3cdb1de4175fc27f0e2f0de2b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab772f3cdb1de4175fc27f0e2f0de2b9d">&#9670;&nbsp;</a></span>getPatternIndicesWithPartitionId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.getPatternIndicesWithPartitionId </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partitionId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:returns: a list of pattern indices corresponding to this partitionId.
Return an empty list if there are none.
</pre> 
</div>
</div>
<a id="a90bfb66151547cad4325ea7b8e66c97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bfb66151547cad4325ea7b8e66c97e">&#9670;&nbsp;</a></span>infer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.infer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>computeScores</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overCategories</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partitionId</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds the category that best matches the input pattern. Returns the
winning category index as well as a distribution over all categories.

:param inputPattern: (list) A pattern to be classified

:param computeScores: NO EFFECT

:param overCategories: NO EFFECT

:param partitionId: (int) If provided, all training vectors with partitionId
equal to that of the input pattern are ignored.
For example, this may be used to perform k-fold cross validation
without repopulating the classifier. First partition all the data into
k equal partitions numbered 0, 1, 2, ... and then call learn() for each
vector passing in its partitionId. Then, during inference, by passing
in the partition ID in the call to infer(), all other vectors with the
same partitionId are ignored simulating the effect of repopulating the
classifier while ommitting the training vectors in the same partition.

:returns: 4-tuple with these keys:

  - ``winner``: The category with the greatest number of nearest neighbors
  within the kth nearest neighbors. If the inferenceResult contains no
  neighbors, the value of winner is None. This can happen, for example,
  in cases of exact matching, if there are no stored vectors, or if
  minSparsity is not met.
  - ``inferenceResult``: A list of length numCategories, each entry contains
  the number of neighbors within the top k neighbors that are in that
  category.
  - ``dist``: A list of length numPrototypes. Each entry is the distance
  from the unknown to that prototype. All distances are between 0.0 and
  1.0.
  - ``categoryDist``: A list of length numCategories. Each entry is the
                distance from the unknown to the nearest prototype of
                that category. All distances are between 0 and 1.0.
</pre> 
</div>
</div>
<a id="a15282d807ba6c5787870da3c6b19e163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15282d807ba6c5787870da3c6b19e163">&#9670;&nbsp;</a></span>learn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.learn </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputCategory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partitionId</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>isSparse</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rowID</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Train the classifier to associate specified input pattern with a
particular category.

:param inputPattern: (list) The pattern to be assigned a category. If
isSparse is 0, this should be a dense array (both ON and OFF bits
present). Otherwise, if isSparse &gt; 0, this should be a list of the
indices of the non-zero bits in sorted order

:param inputCategory: (int) The category to be associated to the training
pattern

:param partitionId: (int) partitionID allows you to associate an id with each
input vector. It can be used to associate input patterns stored in the
classifier with an external id. This can be useful for debugging or
visualizing. Another use case is to ignore vectors with a specific id
during inference (see description of infer() for details). There can be
at most one partitionId per stored pattern (i.e. if two patterns are
within distThreshold, only the first partitionId will be stored). This
is an optional parameter.

:param isSparse: (int) If 0, the input pattern is a dense representation. If
isSparse &gt; 0, the input pattern is a list of non-zero indices and
isSparse is the length of the dense representation

:param rowID: (int) UNKNOWN

:returns: The number of patterns currently stored in the classifier
</pre> 
</div>
</div>
<a id="ab1ac8e70daead1468a7db6f7fcd28dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ac8e70daead1468a7db6f7fcd28dd0">&#9670;&nbsp;</a></span>prototypeSetCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.prototypeSetCategory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idToCategorize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newCategory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Allows ids to be assigned a category and subsequently enables users to use:

  - :meth:`~.KNNClassifier.KNNClassifier.removeCategory`
  - :meth:`~.KNNClassifier.KNNClassifier.closestTrainingPattern`
  - :meth:`~.KNNClassifier.KNNClassifier.closestOtherTrainingPattern`
</pre> 
</div>
</div>
<a id="aa494c742454e9b95c8e27cb0b3160db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa494c742454e9b95c8e27cb0b3160db3">&#9670;&nbsp;</a></span>remapCategories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.remapCategories </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Change the category indices.

Used by the Network Builder to keep the category indices in sync with the
ImageSensor categoryInfo when the user renames or removes categories.

:param mapping: List of new category indices. For example, mapping=[2,0,1]
would change all vectors of category 0 to be category 2, category 1 to
0, and category 2 to 1
</pre> 
</div>
</div>
<a id="aa89e5ed44def8d3dc03d7b2033ae8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89e5ed44def8d3dc03d7b2033ae8539">&#9670;&nbsp;</a></span>removeCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.removeCategory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>categoryToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">There are two caveats. First, this is a potentially slow operation. Second,
pattern indices will shift if patterns before them are removed.

:param categoryToRemove: Category label to remove
</pre> 
</div>
</div>
<a id="a504d715f8ccd363c714b85816b48ffc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504d715f8ccd363c714b85816b48ffc4">&#9670;&nbsp;</a></span>removeIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.removeIds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idsToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">There are two caveats. First, this is a potentially slow operation. Second,
pattern indices will shift if patterns before them are removed.

:param idsToRemove: A list of row indices to remove.
</pre> 
</div>
</div>
<a id="ac147604f38e382b530288587555d0c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac147604f38e382b530288587555d0c7c">&#9670;&nbsp;</a></span>setCategoryOfVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.knn_classifier.KNNClassifier.setCategoryOfVectors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vectorIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>categoryIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Change the category associated with this vector(s).

Used by the Network Builder to move vectors between categories, to enable
categories, and to invalidate vectors by setting the category to -1.

:param vectorIndices: Single index or list of indices

:param categoryIndices: Single index or list of indices. Can also be a
single index when vectorIndices is a list, in which case the same
category will be used for all vectors
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>knn_classifier.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>

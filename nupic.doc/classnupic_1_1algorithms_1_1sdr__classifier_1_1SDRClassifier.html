<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: nupic.algorithms.sdr_classifier.SDRClassifier Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nupic</b></li><li class="navelem"><b>algorithms</b></li><li class="navelem"><b>sdr_classifier</b></li><li class="navelem"><a class="el" href="classnupic_1_1algorithms_1_1sdr__classifier_1_1SDRClassifier.html">SDRClassifier</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classnupic_1_1algorithms_1_1sdr__classifier_1_1SDRClassifier-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nupic.algorithms.sdr_classifier.SDRClassifier Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for nupic.algorithms.sdr_classifier.SDRClassifier:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnupic_1_1algorithms_1_1sdr__classifier_1_1SDRClassifier.png" usemap="#nupic.algorithms.sdr_5Fclassifier.SDRClassifier_map" alt=""/>
  <map id="nupic.algorithms.sdr_5Fclassifier.SDRClassifier_map" name="nupic.algorithms.sdr_5Fclassifier.SDRClassifier_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd65c09fbe4b17d6be0abdfe1c39f866"><td class="memItemLeft" align="right" valign="top"><a id="afd65c09fbe4b17d6be0abdfe1c39f866"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self, steps=(1,), alpha=0.001, actValueAlpha=0.3, verbosity=0)</td></tr>
<tr class="separator:afd65c09fbe4b17d6be0abdfe1c39f866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13bb8ce02d031f0d93da13789c1aa1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1sdr__classifier_1_1SDRClassifier.html#a9b13bb8ce02d031f0d93da13789c1aa1">compute</a> (self, recordNum, patternNZ, classification, learn, <a class="el" href="classnupic_1_1algorithms_1_1sdr__classifier_1_1SDRClassifier.html#a433d6b96e419248e92768109e8c2a0d4">infer</a>)</td></tr>
<tr class="separator:a9b13bb8ce02d031f0d93da13789c1aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d6b96e419248e92768109e8c2a0d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1sdr__classifier_1_1SDRClassifier.html#a433d6b96e419248e92768109e8c2a0d4">infer</a> (self, patternNZ, actValueList)</td></tr>
<tr class="separator:a433d6b96e419248e92768109e8c2a0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b18ad694ebdd75176afaf5b6b8ef7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1algorithms_1_1sdr__classifier_1_1SDRClassifier.html#a79b18ad694ebdd75176afaf5b6b8ef7d">inferSingleStep</a> (self, patternNZ, weightMatrix)</td></tr>
<tr class="separator:a79b18ad694ebdd75176afaf5b6b8ef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199753bcd630d203930e1b538ebfdc31"><td class="memItemLeft" align="right" valign="top"><a id="a199753bcd630d203930e1b538ebfdc31"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>getSchema</b> (cls)</td></tr>
<tr class="separator:a199753bcd630d203930e1b538ebfdc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a9d8aaa82ba8aaa1460b5a3b847ca1"><td class="memItemLeft" align="right" valign="top"><a id="a99a9d8aaa82ba8aaa1460b5a3b847ca1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (cls, proto)</td></tr>
<tr class="separator:a99a9d8aaa82ba8aaa1460b5a3b847ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606d779bd5c1ce9b66bc357116417143"><td class="memItemLeft" align="right" valign="top"><a id="a606d779bd5c1ce9b66bc357116417143"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (self, proto)</td></tr>
<tr class="separator:a606d779bd5c1ce9b66bc357116417143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a91428c6f0ddf6b19215a96085c3010bf"><td class="memItemLeft" align="right" valign="top"><a id="a91428c6f0ddf6b19215a96085c3010bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>steps</b></td></tr>
<tr class="separator:a91428c6f0ddf6b19215a96085c3010bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac769afd87f4d67c806b2ddd08e446011"><td class="memItemLeft" align="right" valign="top"><a id="ac769afd87f4d67c806b2ddd08e446011"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>alpha</b></td></tr>
<tr class="separator:ac769afd87f4d67c806b2ddd08e446011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84bc6621440abed938436bdc80e99e0"><td class="memItemLeft" align="right" valign="top"><a id="ac84bc6621440abed938436bdc80e99e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>actValueAlpha</b></td></tr>
<tr class="separator:ac84bc6621440abed938436bdc80e99e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf08b2b710858973c89094092f3cc09"><td class="memItemLeft" align="right" valign="top"><a id="a9bf08b2b710858973c89094092f3cc09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>verbosity</b></td></tr>
<tr class="separator:a9bf08b2b710858973c89094092f3cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4090157b1bbc2177f79bfae2df24805a"><td class="memItemLeft" align="right" valign="top"><a id="a4090157b1bbc2177f79bfae2df24805a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>VERSION</b> = 1</td></tr>
<tr class="separator:a4090157b1bbc2177f79bfae2df24805a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The SDR Classifier accepts a binary input pattern from the
level below (the "activationPattern") and information from the sensor and
encoders (the "classification") describing the true (target) input.

The SDR classifier maps input patterns to class labels. There are as many
output units as the number of class labels or buckets (in the case of scalar
encoders). The output is a probabilistic distribution over all class labels.

During inference, the output is calculated by first doing a weighted summation
of all the inputs, and then perform a softmax nonlinear function to get
the predicted distribution of class labels

During learning, the connection weights between input units and output units
are adjusted to maximize the likelihood of the model

Example Usage:

.. code-block:: python

   c = SDRClassifier(steps=[1], alpha=0.1, actValueAlpha=0.1, verbosity=0)

   # learning
   c.compute(recordNum=0, patternNZ=[1, 5, 9],
             classification={"bucketIdx": 4, "actValue": 34.7},
             learn=True, infer=False)

   # inference
   result = c.compute(recordNum=1, patternNZ=[1, 5, 9],
                      classification={"bucketIdx": 4, "actValue": 34.7},
                      learn=False, infer=True)

   # Print the top three predictions for 1 steps out.
   topPredictions = sorted(zip(result[1],
                           result["actualValues"]), reverse=True)[:3]
   for probability, value in topPredictions:
     print "Prediction of {} has probability of {}.".format(value,
                                                            probability*100.0)

References:

* Alex Graves. Supervised Sequence Labeling with Recurrent Neural Networks,
  PhD Thesis, 2008
* J. S. Bridle. Probabilistic interpretation of feedforward classification
  network outputs, with relationships to statistical pattern recognition
* In F. Fogleman-Soulie and J.Herault, editors, Neurocomputing: Algorithms,
  Architectures and Applications, pp 227-236, Springer-Verlag, 1990

:param steps: (list) Sequence of the different steps of multi-step predictions
  to learn
:param alpha: (float) The alpha used to adapt the weight matrix during
  learning. A larger alpha results in faster adaptation to the data.
:param actValueAlpha: (float) Used to track the actual value within each
  bucket. A lower actValueAlpha results in longer term memory
:param verbosity: (int) verbosity level, can be 0, 1, or 2

:raises: (ValueError) when record number does not increase monotonically.
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b13bb8ce02d031f0d93da13789c1aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b13bb8ce02d031f0d93da13789c1aa1">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.sdr_classifier.SDRClassifier.compute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recordNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patternNZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>classification</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>learn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>infer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process one input sample.

This method is called by outer loop code outside the nupic-engine. We
use this instead of the nupic engine compute() because our inputs and
outputs aren't fixed size vectors of reals.


:param recordNum: Record number of this input pattern. Record numbers
  normally increase sequentially by 1 each time unless there are missing
  records in the dataset. Knowing this information insures that we don't get
  confused by missing records.

:param patternNZ: List of the active indices from the output below. When the
  input is from TemporalMemory, this list should be the indices of the
  active cells.

:param classification: Dict of the classification information where:

  - bucketIdx: list of indices of the encoder bucket
  - actValue: list of actual values going into the encoder

  Classification could be None for inference mode.
:param learn: (bool) if true, learn this sample
:param infer: (bool) if true, perform inference

:return:    Dict containing inference results, there is one entry for each
        step in self.steps, where the key is the number of steps, and
        the value is an array containing the relative likelihood for
        each bucketIdx starting from bucketIdx 0.

        There is also an entry containing the average actual value to
        use for each bucket. The key is 'actualValues'.

        for example:

        .. code-block:: python

           {1 :             [0.1, 0.3, 0.2, 0.7],
             4 :             [0.2, 0.4, 0.3, 0.5],
             'actualValues': [1.5, 3,5, 5,5, 7.6],
           }
</pre> 
</div>
</div>
<a id="a433d6b96e419248e92768109e8c2a0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433d6b96e419248e92768109e8c2a0d4">&#9670;&nbsp;</a></span>infer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.sdr_classifier.SDRClassifier.infer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patternNZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>actValueList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the inference value from one input sample. The actual
learning happens in compute().

:param patternNZ: list of the active indices from the output below
:param classification: dict of the classification information:
            bucketIdx: index of the encoder bucket
            actValue:  actual value going into the encoder

:return:    dict containing inference results, one entry for each step in
        self.steps. The key is the number of steps, the value is an
        array containing the relative likelihood for each bucketIdx
        starting from bucketIdx 0.

        for example:

        .. code-block:: python

           {'actualValues': [0.0, 1.0, 2.0, 3.0]
             1 : [0.1, 0.3, 0.2, 0.7]
             4 : [0.2, 0.4, 0.3, 0.5]}
</pre> 
</div>
</div>
<a id="a79b18ad694ebdd75176afaf5b6b8ef7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b18ad694ebdd75176afaf5b6b8ef7d">&#9670;&nbsp;</a></span>inferSingleStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def nupic.algorithms.sdr_classifier.SDRClassifier.inferSingleStep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patternNZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weightMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform inference for a single step. Given an SDR input and a weight
matrix, return a predicted distribution.

:param patternNZ: list of the active indices from the output below
:param weightMatrix: numpy array of the weight matrix
:return: numpy array of the predicted class label distribution
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sdr_classifier.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
